import { sharedConfig, awaitSuspense, splitProps } from 'solid-js';
export { ErrorBoundary, For, Index, Match, Show, Suspense, SuspenseList, Switch, createComponent, mergeProps } from 'solid-js';

const booleans = ["allowfullscreen", "async", "autofocus", "autoplay", "checked", "controls", "default", "disabled", "formnovalidate", "hidden", "indeterminate", "ismap", "loop", "multiple", "muted", "nomodule", "novalidate", "open", "playsinline", "readonly", "required", "reversed", "seamless", "selected"];
const BooleanAttributes = new Set(booleans);
new Set(["className", "value", "readOnly", "formNoValidate", "isMap", "noModule", "playsInline", ...booleans]);
const Aliases = {
  className: "class",
  htmlFor: "for"
};

var chars = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved = /^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped = {
  '<': '\\u003C',
  '>': '\\u003E',
  '/': '\\u002F',
  '\\': '\\\\',
  '\b': '\\b',
  '\f': '\\f',
  '\n': '\\n',
  '\r': '\\r',
  '\t': '\\t',
  '\0': '\\0',
  '\u2028': '\\u2028',
  '\u2029': '\\u2029'
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join('\0');
function devalue(value) {
  var counts = new Map();
  function walk(thing) {
    if (typeof thing === 'function') {
      throw new Error("Cannot stringify a function");
    }
    if (counts.has(thing)) {
      counts.set(thing, counts.get(thing) + 1);
      return;
    }
    counts.set(thing, 1);
    if (!isPrimitive(thing)) {
      var type = getType(thing);
      switch (type) {
        case 'Number':
        case 'String':
        case 'Boolean':
        case 'Date':
        case 'RegExp':
          return;
        case 'Array':
          thing.forEach(walk);
          break;
        case 'Set':
        case 'Map':
          Array.from(thing).forEach(walk);
          break;
        default:
          var proto = Object.getPrototypeOf(thing);
          if (proto !== Object.prototype && proto !== null && Object.getOwnPropertyNames(proto).sort().join('\0') !== objectProtoOwnPropertyNames) {
            throw new Error("Cannot stringify arbitrary non-POJOs");
          }
          if (Object.getOwnPropertySymbols(thing).length > 0) {
            throw new Error("Cannot stringify POJOs with symbolic keys");
          }
          Object.keys(thing).forEach(function (key) {
            return walk(thing[key]);
          });
      }
    }
  }
  walk(value);
  var names = new Map();
  Array.from(counts).filter(function (entry) {
    return entry[1] > 1;
  }).sort(function (a, b) {
    return b[1] - a[1];
  }).forEach(function (entry, i) {
    names.set(entry[0], getName(i));
  });
  function stringify(thing) {
    if (names.has(thing)) {
      return names.get(thing);
    }
    if (isPrimitive(thing)) {
      return stringifyPrimitive(thing);
    }
    var type = getType(thing);
    switch (type) {
      case 'Number':
      case 'String':
      case 'Boolean':
        return "Object(" + stringify(thing.valueOf()) + ")";
      case 'RegExp':
        return "new RegExp(" + stringifyString(thing.source) + ", \"" + thing.flags + "\")";
      case 'Date':
        return "new Date(" + thing.getTime() + ")";
      case 'Array':
        var members = thing.map(function (v, i) {
          return i in thing ? stringify(v) : '';
        });
        var tail = thing.length === 0 || thing.length - 1 in thing ? '' : ',';
        return "[" + members.join(',') + tail + "]";
      case 'Set':
      case 'Map':
        return "new " + type + "([" + Array.from(thing).map(stringify).join(',') + "])";
      default:
        var obj = "{" + Object.keys(thing).map(function (key) {
          return safeKey(key) + ":" + stringify(thing[key]);
        }).join(',') + "}";
        var proto = Object.getPrototypeOf(thing);
        if (proto === null) {
          return Object.keys(thing).length > 0 ? "Object.assign(Object.create(null)," + obj + ")" : "Object.create(null)";
        }
        return obj;
    }
  }
  var str = stringify(value);
  if (names.size) {
    var params_1 = [];
    var statements_1 = [];
    var values_1 = [];
    names.forEach(function (name, thing) {
      params_1.push(name);
      if (isPrimitive(thing)) {
        values_1.push(stringifyPrimitive(thing));
        return;
      }
      var type = getType(thing);
      switch (type) {
        case 'Number':
        case 'String':
        case 'Boolean':
          values_1.push("Object(" + stringify(thing.valueOf()) + ")");
          break;
        case 'RegExp':
          values_1.push(thing.toString());
          break;
        case 'Date':
          values_1.push("new Date(" + thing.getTime() + ")");
          break;
        case 'Array':
          values_1.push("Array(" + thing.length + ")");
          thing.forEach(function (v, i) {
            statements_1.push(name + "[" + i + "]=" + stringify(v));
          });
          break;
        case 'Set':
          values_1.push("new Set");
          statements_1.push(name + "." + Array.from(thing).map(function (v) {
            return "add(" + stringify(v) + ")";
          }).join('.'));
          break;
        case 'Map':
          values_1.push("new Map");
          statements_1.push(name + "." + Array.from(thing).map(function (_a) {
            var k = _a[0],
                v = _a[1];
            return "set(" + stringify(k) + ", " + stringify(v) + ")";
          }).join('.'));
          break;
        default:
          values_1.push(Object.getPrototypeOf(thing) === null ? 'Object.create(null)' : '{}');
          Object.keys(thing).forEach(function (key) {
            statements_1.push("" + name + safeProp(key) + "=" + stringify(thing[key]));
          });
      }
    });
    statements_1.push("return " + str);
    return "(function(" + params_1.join(',') + "){" + statements_1.join(';') + "}(" + values_1.join(',') + "))";
  } else {
    return str;
  }
}
function getName(num) {
  var name = '';
  do {
    name = chars[num % chars.length] + name;
    num = ~~(num / chars.length) - 1;
  } while (num >= 0);
  return reserved.test(name) ? name + "_" : name;
}
function isPrimitive(thing) {
  return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
  if (typeof thing === 'string') return stringifyString(thing);
  if (thing === void 0) return 'void 0';
  if (thing === 0 && 1 / thing < 0) return '-0';
  var str = String(thing);
  if (typeof thing === 'number') return str.replace(/^(-)?0\./, '$1.');
  return str;
}
function getType(thing) {
  return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
  return escaped[c] || c;
}
function escapeUnsafeChars(str) {
  return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? key : escapeUnsafeChars(JSON.stringify(key));
}
function safeProp(key) {
  return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key) ? "." + key : "[" + escapeUnsafeChars(JSON.stringify(key)) + "]";
}
function stringifyString(str) {
  var result = '"';
  for (var i = 0; i < str.length; i += 1) {
    var char = str.charAt(i);
    var code = char.charCodeAt(0);
    if (char === '"') {
      result += '\\"';
    } else if (char in escaped) {
      result += escaped[char];
    } else if (code >= 0xd800 && code <= 0xdfff) {
      var next = str.charCodeAt(i + 1);
      if (code <= 0xdbff && next >= 0xdc00 && next <= 0xdfff) {
        result += char + str[++i];
      } else {
        result += "\\u" + code.toString(16).toUpperCase();
      }
    } else {
      result += char;
    }
  }
  result += '"';
  return result;
}

function renderToString(code, options = {}) {
  sharedConfig.context = Object.assign({
    id: "",
    count: 0,
    assets: []
  }, options);
  let html = resolveSSRNode(escape(code()));
  return injectAssets(sharedConfig.context.assets, html);
}
function renderToStringAsync(code, options = {}) {
  options = {
    timeoutMs: 30000,
    ...options
  };
  const context = sharedConfig.context = Object.assign({
    id: "",
    count: 0,
    resources: {},
    suspense: {},
    assets: [],
    async: true
  }, options);
  const timeout = new Promise((_, reject) => setTimeout(() => reject("renderToString timed out"), options.timeoutMs));
  return Promise.race([awaitSuspense(() => escape(code())), timeout]).then(res => {
    let html = resolveSSRNode(res);
    return injectAssets(context.assets, html);
  });
}
function pipeToNodeWritable(code, writable, options = {}) {
  const {
    nonce,
    onReady = ({
      startWriting
    }) => startWriting(),
    onComplete
  } = options;
  const tmp = [];
  let count = 0,
      completed = 0,
      buffer = {
    write(payload) {
      tmp.push(payload);
    }
  };
  const result = {
    startWriting() {
      buffer = writable;
      tmp.forEach(chunk => buffer.write(chunk));
      setTimeout(checkEnd);
    },
    write(c) {
      writable.write(c);
    },
    abort() {
      completed = count;
      checkEnd();
    }
  };
  const checkEnd = () => {
    if (completed === count) {
      onComplete && onComplete(result);
      writable.end();
    }
  };
  sharedConfig.context = Object.assign({
    id: "",
    count: 0,
    streaming: true,
    suspense: {},
    assets: []
  }, options);
  sharedConfig.context.writeResource = (id, p) => {
    count++;
    Promise.resolve().then(() => buffer.write(`<script${nonce ? ` nonce="${nonce}"` : ""}>_$HYDRATION.startResource("${id}")</script>`));
    p.then(d => {
      buffer.write(`<script${nonce ? ` nonce="${nonce}"` : ""}>_$HYDRATION.resolveResource("${id}", ${devalue(d)})</script>`);
      ++completed && checkEnd();
    });
  };
  let html = resolveSSRNode(escape(code()));
  html = injectAssets(sharedConfig.context.assets, html);
  buffer.write(html);
  onReady(result);
}
function pipeToWritable(code, writable, options = {}) {
  const {
    nonce,
    onReady = ({
      startWriting
    }) => startWriting(),
    onComplete
  } = options;
  const tmp = [];
  const writer = writable.getWriter();
  const encoder = new TextEncoder();
  sharedConfig.context = Object.assign({
    id: "",
    count: 0,
    streaming: true,
    suspense: {},
    assets: []
  }, options);
  let count = 0,
      completed = 0,
      buffer = {
    write(payload) {
      tmp.push(payload);
    }
  };
  const result = {
    startWriting() {
      buffer = writer;
      tmp.forEach(chunk => writer.write(chunk));
      setTimeout(checkEnd);
    },
    write(c) {
      writer.write(encoder.encode(c));
    },
    abort() {
      completed = count;
      checkEnd();
    }
  };
  const checkEnd = () => {
    if (completed === count) {
      onComplete && onComplete(result);
      writable.close();
    }
  };
  sharedConfig.context.writeResource = (id, p) => {
    count++;
    Promise.resolve().then(() => buffer.write(encoder.encode(`<script${nonce ? ` nonce="${nonce}"` : ""}>_$HYDRATION.startResource("${id}")</script>`)));
    p.then(d => {
      buffer.write(encoder.encode(`<script${nonce ? ` nonce="${nonce}"` : ""}>_$HYDRATION.resolveResource("${id}", ${devalue(d)})</script>`));
      ++completed && checkEnd();
    });
  };
  let html = resolveSSRNode(escape(code()));
  html = injectAssets(sharedConfig.context.assets, html);
  buffer.write(encoder.encode(html));
  onReady(result);
}
function Assets(props) {
  sharedConfig.context.assets.push(() => NoHydration({
    get children() {
      return resolveSSRNode(props.children);
    }
  }));
  return ssr(`%%$${sharedConfig.context.assets.length - 1}%%`);
}
function HydrationScript() {
  sharedConfig.context.assets.push(generateHydrationScript);
  return ssr(`%%$${sharedConfig.context.assets.length - 1}%%`);
}
function NoHydration(props) {
  const c = sharedConfig.context;
  delete sharedConfig.context;
  const children = props.children;
  sharedConfig.context = c;
  return children;
}
function ssr(t, ...nodes) {
  if (nodes.length) {
    let result = "";
    for (let i = 0; i < t.length; i++) {
      result += t[i];
      const node = nodes[i];
      if (node !== undefined) result += resolveSSRNode(node);
    }
    t = result;
  }
  return {
    t
  };
}
function ssrClassList(value) {
  if (!value) return "";
  let classKeys = Object.keys(value),
      result = "";
  for (let i = 0, len = classKeys.length; i < len; i++) {
    const key = classKeys[i],
          classValue = !!value[key];
    if (!key || !classValue) continue;
    i && (result += " ");
    result += key;
  }
  return result;
}
function ssrStyle(value) {
  if (!value) return "";
  if (typeof value === "string") return value;
  let result = "";
  const k = Object.keys(value);
  for (let i = 0; i < k.length; i++) {
    const s = k[i];
    if (i) result += ";";
    result += `${s}:${escape(value[s], true)}`;
  }
  return result;
}
function ssrSpread(props, isSVG, skipChildren) {
  if (typeof props === "function") props = props();
  const keys = Object.keys(props);
  let result = "";
  for (let i = 0; i < keys.length; i++) {
    const prop = keys[i];
    if (prop === "children") {
      !skipChildren && console.warn(`SSR currently does not support spread children.`);
      continue;
    }
    const value = props[prop];
    if (prop === "style") {
      result += `style="${ssrStyle(value)}"`;
    } else if (prop === "classList") {
      result += `class="${ssrClassList(value)}"`;
    } else if (BooleanAttributes.has(prop)) {
      if (value) result += prop;else continue;
    } else if (prop === "ref" || prop.slice(0, 2) === "on") {
      continue;
    } else {
      result += `${Aliases[prop] || prop}="${escape(value, true)}"`;
    }
    if (i !== keys.length - 1) result += " ";
  }
  return result;
}
function ssrBoolean(key, value) {
  return value ? " " + key : "";
}
function ssrHydrationKey() {
  const hk = getHydrationKey();
  return hk ? ` data-hk="${hk}"` : "";
}
function escape(s, attr) {
  const t = typeof s;
  if (t !== "string") {
    if (!attr && t === "function") return escape(s(), attr);
    if (attr && t === "boolean") return String(s);
    return s;
  }
  const delim = attr ? '"' : "<";
  const escDelim = attr ? "&quot;" : "&lt;";
  let iDelim = s.indexOf(delim);
  let iAmp = s.indexOf("&");
  if (iDelim < 0 && iAmp < 0) return s;
  let left = 0,
      out = "";
  while (iDelim >= 0 && iAmp >= 0) {
    if (iDelim < iAmp) {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } else {
      if (left < iAmp) out += s.substring(left, iAmp);
      out += "&amp;";
      left = iAmp + 1;
      iAmp = s.indexOf("&", left);
    }
  }
  if (iDelim >= 0) {
    do {
      if (left < iDelim) out += s.substring(left, iDelim);
      out += escDelim;
      left = iDelim + 1;
      iDelim = s.indexOf(delim, left);
    } while (iDelim >= 0);
  } else while (iAmp >= 0) {
    if (left < iAmp) out += s.substring(left, iAmp);
    out += "&amp;";
    left = iAmp + 1;
    iAmp = s.indexOf("&", left);
  }
  return left < s.length ? out + s.substring(left) : out;
}
function resolveSSRNode(node) {
  const t = typeof node;
  if (t === "string") return node;
  if (node == null || t === "boolean") return "";
  if (Array.isArray(node)) return node.map(resolveSSRNode).join("");
  if (t === "object") return resolveSSRNode(node.t);
  if (t === "function") return resolveSSRNode(node());
  return String(node);
}
function getHydrationKey() {
  const hydrate = sharedConfig.context;
  return hydrate && `${hydrate.id}${hydrate.count++}`;
}
function generateHydrationScript() {
  const {
    nonce,
    streaming,
    resources,
    eventNames = ["click", "input"]
  } = sharedConfig.context;
  let s = `<script${nonce ? ` nonce="${nonce}"` : ""}>(()=>{_$HYDRATION={events:[],completed:new WeakSet};const t=e=>e&&e.hasAttribute&&(e.hasAttribute("data-hk")?e:t(e.host&&e.host instanceof Node?e.host:e.parentNode)),e=e=>{let o=e.composedPath&&e.composedPath()[0]||e.target,s=t(o);s&&!_$HYDRATION.completed.has(s)&&_$HYDRATION.events.push([s,e])};["${eventNames.join('","')}"].forEach(t=>document.addEventListener(t,e))})();`;
  if (streaming) {
    s += `(()=>{const e=_$HYDRATION,o={};e.startResource=e=>{let r;o[e]=[new Promise(e=>r=e),r]},e.resolveResource=(e,r)=>{const n=o[e];if(!n)return o[e]=[r];n[1](r)},e.loadResource=e=>{const r=o[e];if(r)return r[0]}})();`;
  }
  if (resources) {
    s += `_$HYDRATION.resources = ${devalue(Object.keys(resources).reduce((r, k) => {
      r[k] = resources[k].data;
      return r;
    }, {}))};`;
  }
  return s + `</script>`;
}
function injectAssets(assets, html) {
  for (let i = 0; i < assets.length; i++) {
    html = html.replace(`%%$${i}%%`, assets[i]());
  }
  return html;
}

const isServer = true;
function spread() {}
function Dynamic(props) {
  const [p, others] = splitProps(props, ["component"]);
  const comp = p.component,
        t = typeof comp;
  if (comp) {
    if (t === "function") return comp(others);else if (t === "string") {
      const [local, sOthers] = splitProps(others, ["children"]);
      return ssr([`<${comp}`, ' ', ">", `</${comp}>`], ssrHydrationKey(), ssrSpread(sOthers), local.children || "");
    }
  }
}
function Portal(props) {
  return "";
}

export { Assets, Dynamic, HydrationScript, NoHydration, Portal, escape, generateHydrationScript, getHydrationKey, isServer, pipeToNodeWritable, pipeToWritable, renderToString, renderToStringAsync, resolveSSRNode, spread, ssr, ssrBoolean, ssrClassList, ssrHydrationKey, ssrSpread, ssrStyle };
