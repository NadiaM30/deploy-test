import { transformAsync } from '@babel/core';
import ts from '@babel/preset-typescript';
import solid from 'babel-preset-solid';
import { readFileSync } from 'fs';
import { mergeAndConcat } from 'merge-anything';
import { createRequire } from 'module';
import solidRefresh from 'solid-refresh/babel.js';

const require = createRequire(import.meta.url);

const runtimePublicPath = '/@solid-refresh';

const runtimeFilePath = require.resolve('solid-refresh/dist/solid-refresh.mjs');

const runtimeCode = readFileSync(runtimeFilePath, 'utf-8');
/** Configuration options for vite-plugin-solid. */

function solidPlugin(options = {}) {
  let needHmr = false;
  let replaceDev = false;
  let projectRoot = process.cwd();
  return {
    name: 'solid',
    enforce: 'pre',

    config(userConfig, {
      command
    }) {
      var _userConfig$resolve;

      // We inject the dev mode only if the user explicitely wants it or if we are in dev (serve) mode
      replaceDev = options.dev === true || options.dev !== false && command === 'serve';
      projectRoot = userConfig.root; // TODO: remove when fully removed from vite

      const legacyAlias = normalizeAliases(userConfig.alias);
      if (!userConfig.resolve) userConfig.resolve = {};
      userConfig.resolve.alias = [...legacyAlias, ...normalizeAliases((_userConfig$resolve = userConfig.resolve) === null || _userConfig$resolve === void 0 ? void 0 : _userConfig$resolve.alias)]; // fix for bundling dev in production

      const nestedDeps = replaceDev ? ['solid-js', 'solid-js/web', 'solid-js/store', 'solid-js/html', 'solid-js/h'] : [];
      return {
        /**
         * We only need esbuild on .ts or .js files.
         * .tsx & .jsx files are handled by us
         */
        esbuild: {
          include: /\.ts$/
        },
        resolve: {
          conditions: ['solid', ...(replaceDev ? ['development'] : [])],
          dedupe: nestedDeps,
          alias: [{
            find: /^solid-refresh$/,
            replacement: runtimePublicPath
          }]
        },
        optimizeDeps: {
          include: nestedDeps
        }
      };
    },

    configResolved(config) {
      needHmr = config.command === 'serve' && !config.isProduction && options.hot !== false;
    },

    resolveId(id) {
      if (id === runtimePublicPath) return id;
    },

    load(id) {
      if (id === runtimePublicPath) return runtimeCode;
    },

    async transform(source, id, transformOptions) {
      // @ts-expect-error anticipate vite changing second parameter as options object
      // see https://github.com/vitejs/vite/discussions/5109
      const ssr = transformOptions === true || (transformOptions === null || transformOptions === void 0 ? void 0 : transformOptions.ssr);
      if (!/\.[jt]sx/.test(id)) return null;
      const inNodeModules = /node_modules/.test(id);
      let solidOptions;

      if (options.ssr) {
        if (ssr) {
          solidOptions = {
            generate: 'ssr',
            hydratable: true
          };
        } else {
          solidOptions = {
            generate: 'dom',
            hydratable: true
          };
        }
      } else {
        solidOptions = {
          generate: 'dom',
          hydratable: false
        };
      }

      const opts = {
        babelrc: false,
        configFile: false,
        root: projectRoot,
        filename: id,
        sourceFileName: id,
        presets: [[solid, { ...solidOptions,
          ...(options.solid || {})
        }]],
        plugins: needHmr && !inNodeModules ? [[solidRefresh, {
          bundler: 'vite'
        }]] : [],
        sourceMaps: true,
        // Vite handles sourcemap flattening
        inputSourceMap: false
      };

      if (id.includes('tsx')) {
        opts.presets.push([ts, options.typescript || {}]);
      } // Default value for babel user options


      let babelUserOptions = {};

      if (options.babel) {
        if (typeof options.babel === 'function') {
          const babelOptions = options.babel(source, id, ssr);
          babelUserOptions = babelOptions instanceof Promise ? await babelOptions : babelOptions;
        } else {
          babelUserOptions = options.babel;
        }
      }

      const babelOptions = mergeAndConcat(babelUserOptions, opts);
      const {
        code,
        map
      } = await transformAsync(source, babelOptions);
      return {
        code,
        map
      };
    }

  };
}
/**
 * This basically normalize all aliases of the config into
 * the array format of the alias.
 *
 * eg: alias: { '@': 'src/' } => [{ find: '@', replacement: 'src/' }]
 */

function normalizeAliases(alias = []) {
  return Array.isArray(alias) ? alias : Object.entries(alias).map(([find, replacement]) => ({
    find,
    replacement
  }));
}

export { solidPlugin as default };
//# sourceMappingURL=index.mjs.map
